#第一步：在宿主机（Ubuntu 24.04）执行

#这步负责创建文件夹并启动容器。

mkdir -p ~/project_build && \
docker run -it \
  --name ubuntu20_dev \
  -v ~/project_build:/work \
  ubuntu:20.04 bash # 👈 在这里指定了20.04版本

#第二步：在容器内（Ubuntu 20.04）执行

#进入容器后，直接复制下面这整块代码。
#修正点：已添加阿里云源加速，并加入了 DEBIAN_FRONTEND=noninteractive 参数，彻底解决卡在“选择时区”的问题。

sed -i 's@//.*archive.ubuntu.com@//mirrors.aliyun.com@g' /etc/apt/sources.list && \
sed -i 's@//.*security.ubuntu.com@//mirrors.aliyun.com@g' /etc/apt/sources.list && \
apt-get update && \
export DEBIAN_FRONTEND=noninteractive && \
apt-get install -y build-essential git vim cmake gdb && \
echo "------------------------------------------------" && \
echo "配置完成！当前环境 GCC 版本：" && gcc --version


#第三步：验证“宿主机写代码，容器编译”
#我们要验证文件挂载是否成功，以及编译器能否正常生成可执行文件。请在容器终端内直接复制执行：
rm -f test_env.c && \
cat > test_env.c <<EOF
#include <stdio.h>
int main() {
    printf("Success: Environment is ready!\\n");
    return 0;
}
EOF
gcc test_env.c -o test_app && \
./test_app

#如果输出： Success: Environment is ready!即表示成功。




第四步：日常开发流程

写代码（在宿主机）：
直接用文件管理器打开 ~/project_build 文件夹，用 VS Code 或编辑器修改保存代码。

编译（在容器）：
在容器终端（root@...:/work#）里执行编译命令（如 gcc xxx.c 或 make）。

第五步：重新打开终端进入环境

每次重启电脑或打开新终端时，只需执行这一条指令即可进入编译环境：

docker start -ai ubuntu20_dev

| 部分 | 作用 | 技术细节 |
|------|------|----------|
| `docker start` | 启动已存在的停止容器 | ≠ `docker run`（创建+启动新容器） |
| `-a` (`--attach`) | 附加到容器的主进程输出流 | 捕获 STDOUT/STDERR，实时显示日志 |
| `-i` (`--interactive`) | 保持标准输入(STDIN)打开 | 允许与容器内进程交互（如 bash） |
| `ubuntu20_dev` | 目标容器名称 | 通过 `docker ps -a` 可查看所有容器 |

(输入 exit 或Ctrl+D即可退出)




EXTRA:
一个非常经典的概念误区：Docker 容器是与宿主机隔离的。
你之前启动容器时只挂载了 ~/project_build，并没有挂载 ~/BSP，所以容器根本“看不见”这个目录。
无法给已存在的容器直接追加目录，必须删除旧容器，重新创建一个挂载了 SDK 的容器。
请按顺序执行下面两步（注意：这会重置容器内的环境，所以第二步会自动帮你把 GCC 等工具重新装回来）：

第一步：删除旧容器并重新启动（挂载 SDK）
(请直接复制并在宿主机终端执行，这将把你的 ~/BSP 映射到容器内的 /BSP 目录)

docker rm -f ubuntu20_dev && \
docker run -it \
  --name ubuntu20_dev \
  -v ~/project_build:/work \
  -v ~/BSP:/BSP \
  ubuntu:20.04 bash # 👈 同样在这里指定了20.04版本


第二步：一键恢复编译环境（在容器内执行）
(因为是新容器，需要重新配置加速源和安装工具，复制下面代码执行即可)
sed -i 's@//.*archive.ubuntu.com@//mirrors.aliyun.com@g' /etc/apt/sources.list && \
sed -i 's@//.*security.ubuntu.com@//mirrors.aliyun.com@g' /etc/apt/sources.list && \
apt-get update && \
export DEBIAN_FRONTEND=noninteractive && \
apt-get install -y build-essential git vim cmake gdb && \
echo "------------------------------------------------" && \
echo "环境恢复完成！SDK 路径位于 /BSP" && \
ls /BSP


上述代码分析：

这段代码构建了一个专用于嵌入式开发（Rockchip SDK）的 Docker 环境。下面是详细的逐行分析，帮助你理解每一句指令背后的含义和作用：

第一步：容器重构与挂载
核心目的：创建一个新的容器，让它既能编译代码，又能直接读写你宿主机里的 SDK 文件。

docker rm -f ubuntu20_dev && \
# 解析：强制删除(-f)名为 ubuntu20_dev 的旧容器。
# 为什么要删？因为 Docker 不允许更改已存在容器的挂载目录。要想增加 /BSP 映射，必须销毁旧的，建立新的。
# 注意：这会丢弃容器系统内部（非挂载目录）的所有临时文件，但不会影响你电脑上的源码。

docker run -it \
# 解析：启动新容器。
# -i: 保持标准输入开启（让你可以输入命令）。
# -t: 分配伪终端（给你一个像平常一样的黑框框）。

  --name ubuntu20_dev \
# 解析：给容器起个固定的名字，方便以后用 docker start ubuntu20_dev 唤醒它。

  -v ~/project_build:/work \
# 解析：【关键点1】将宿主机的 ~/project_build 目录 映射到 容器内的 /work。
# 作用：平时写的小代码放这里。

  -v ~/BSP:/BSP \
# 解析：【关键点2】将宿主机的 ~/BSP 目录 映射到 容器内的 /BSP。
# 作用：你的 Rockchip SDK 巨大（通常几十GB），直接映射进去，既不用复制也不占双倍空间。

  ubuntu:20.04 bash
# 解析：基于 Ubuntu 20.04 镜像，启动后执行 bash 命令行。

第二步：环境初始化
核心目的：把这个“裸”的 Ubuntu 系统变成一个“能干活”的开发环境，解决“下载慢”和“安装卡住”的问题。

sed -i 's@//.*archive.ubuntu.com@//mirrors.aliyun.com@g' /etc/apt/sources.list && \
sed -i 's@//.*security.ubuntu.com@//mirrors.aliyun.com@g' /etc/apt/sources.list && \
# 解析：换源。
# 使用 sed 命令批量将默认的官方源（archive.ubuntu.com）替换为阿里云镜像源。
# 作用：让 apt-get 下载速度从“几KB/s”提升到“满速”，这是在国内使用 Docker 的必须操作。

apt-get update && \
# 解析：更新软件列表。告诉系统现在有了新的阿里云源，去获取最新的软件版本信息。

export DEBIAN_FRONTEND=noninteractive && \
# 解析：【防坑关键点】设置“非交互模式”。
# 作用：告诉系统“无论发生什么都别问我问题”。这完美解决了你之前遇到的“选择时区（Timezone）”卡死的问题。

apt-get install -y build-essential git vim cmake gdb && \
# 解析：安装基础工具包。
# build-essential: 包含 gcc, g++, make, libc-dev 等编译核心。
# git/vim/cmake/gdb: 开发必备的辅助工具。
# -y: 自动回答 Yes，确认安装。

echo "..." && ls /BSP
# 解析：验证。打印提示信息，并列出 /BSP 目录的内容，让你直观看到挂载成功了。

总结
这套指令执行完后，你拥有了一个：
完全隔离：环境弄乱了删掉重来即可，不影响宿主机。
文件互通：你在宿主机修改 SDK 源码，容器里能立即编译。
高速网络：配置了阿里云源，装软件很快。
无交互干扰：修复了时区配置卡死的问题。
特别提示：
你现在只是安装了通用的 C/C++ 编译环境。
正如我上一条回复所说，编译 Rockchip SDK（rk356x）还需要额外的一堆依赖包（如 lzop, bc, device-tree-compiler 等）。记得执行我刚才补发的那段 apt-get install ... 指令来完善环境。