注意：
用ubuntu原生版本而非sdk原始版本的编译要先升级sdk的关键包（硬刚 24.04）
如果你坚持要在本机 Ubuntu 24.04 上编译，那么在重新解压 SDK 之后、运行 build.sh 之前，请先执行以下几个“预处理”步骤，能避开 99% 的坑。
直接升级 host-fakeroot (最关键)
这是导致你最后打包失败的元凶。旧版 fakeroot 无法在新 Linux 内核/Glibc 上运行。
编辑文件：buildroot/package/fakeroot/fakeroot.mk
修改版本号和环境：
将：fakeroot.mk改成以下：
cat << 'EOF' > buildroot/package/fakeroot/fakeroot.mk
################################################################################
#
# fakeroot
#
################################################################################

FAKEROOT_VERSION = 1.32.1
FAKEROOT_SOURCE = fakeroot_$(FAKEROOT_VERSION).orig.tar.gz
# 你的本地已经有文件了，这个地址用于备份
FAKEROOT_SITE = https://snapshot.debian.org/archive/debian/20230724T160429Z/pool/main/f/fakeroot

FAKEROOT_AUTORECONF = YES

# 依赖项
HOST_FAKEROOT_DEPENDENCIES = host-acl host-gettext host-pkgconf

# 禁用 capability
HOST_FAKEROOT_CONF_ENV = \
	ac_cv_header_sys_capability_h=no \
	ac_cv_func_capset=no

FAKEROOT_LICENSE = GPL-3.0+
FAKEROOT_LICENSE_FILES = COPYING

HOST_FAKEROOT_CONF_ENV += CFLAGS="$(HOST_CFLAGS) -fcommon"

# --- 关键修复开始 ---
# 定义一个钩子：在打补丁之后、配置之前，强行把 configure.ac 里的 2.71 改成 2.69
# 这样旧版 Buildroot 的 Autoconf 就能通过检查了
define HOST_FAKEROOT_FIX_AUTOCONF_VERSION
	$(SED) 's/2\.71/2.69/g' $(@D)/configure.ac
endef

# 将这个钩子注册到 host-fakeroot 的构建流程中
HOST_FAKEROOT_POST_PATCH_HOOKS += HOST_FAKEROOT_FIX_AUTOCONF_VERSION
# --- 关键修复结束 ---

$(eval $(host-autotools-package))
EOF



#删除旧 Hash：
rm buildroot/package/fakeroot/fakeroot.hash

#旧的补丁文件打在新的 1.32.1 源码上肯定会报错（Apply failed），导致编译停止。
# 进入 Buildroot 目录
cd /home/wzp/BSP/rk356x_linux/buildroot

# 删除 fakeroot 目录下的所有补丁文件
rm -f package/fakeroot/*.patch

# 再次确认清理了旧的编译缓存
rm -rf output/rockchip_rk356x_recovery/build/host-fakeroot-*


#下载fakeroot_1.32.1
mkdir -p /home/wzp/BSP/rk356x_linux/buildroot/dl
cd /home/wzp/BSP/rk356x_linux/buildroot/dl

# 使用 Buildroot 官方备份源下载 (速度快且稳定)
wget https://sources.buildroot.net/fakeroot/fakeroot_1.32.1.orig.tar.gz


 

#进入rk356x_linux终端后可执行./build.sh进行编译
cd /home/wzp/BSP/rk356x_linux
./build.sh recovery




由于 Buildroot 的机制是 “先解压源码，再编译”，所以这些文件在刚开始解压 SDK 时是不存在的。

需要采用 “遇到报错 -> 执行对应修复指令 -> 继续编译” 的策略。

这里整理好了你需要的 Sed 一键修复指令。

这些指令分为两组：一组针对 Recovery（rockchip_rk356x_recovery），一组针对 主系统（rockchip_rk3568）。

请注意：必须等到编译报错（源码解压出来后）再执行对应的指令，否则会提示“文件不存在”。

一、 修复 host-m4 (SIGSTKSZ 问题)
2025-12-31T21:26:53 >>> host-m4 1.4.18 Building
报错特征：c-stack.c:55:26: error: missing binary operator before token "("

1. 针对 Recovery 目录
# 替换 c-stack.c 中的代码块
sed -i '/^#ifndef SIGSTKSZ/,/^#endif/c\/* 修复 host-m4 在新版 glibc 编译报错的问题 */\n#ifdef SIGSTKSZ\n# undef SIGSTKSZ\n#endif\n#define SIGSTKSZ 16384' \
buildroot/output/rockchip_rk356x_recovery/build/host-m4-1.4.18/lib/c-stack.c
./build.sh recovery

2. 针对 Buildroot 主系统目录
# 替换 c-stack.c 中的代码块
sed -i '/^#ifndef SIGSTKSZ/,/^#endif/c\/* 修复 host-m4 在新版 glibc 编译报错的问题 */\n#ifdef SIGSTKSZ\n# undef SIGSTKSZ\n#endif\n#define SIGSTKSZ 16384' \
buildroot/output/rockchip_rk3568/build/host-m4-1.4.18/lib/c-stack.c
./build.sh buildroot


二、 修复 Makefile/host-squashfs (fcommon & sysmacros 问题)
2026-01-01T01:38:39 >>> host-squashfs 3de1687d7432ea9b302c2db9521996f506c140a3 Building
报错特征：multiple definition 或 sys/types.h 相关错误。
这里我们只修改头文件和Makefile，不需要改那十几个 .c 文件，效果是一样的。

1. 针对 Recovery 目录
# 1. 在头文件 squashfs_fs.h 第一行插入 sysmacros.h
sed -i '1i#include <sys/sysmacros.h>' \
buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-*/squashfs-tools/squashfs_fs.h
# 2. 在 Makefile 中添加 -fcommon
sed -i 's/CFLAGS ?= -O2/CFLAGS ?= -O2 -fcommon/' \
buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-*/squashfs-tools/Makefile
# 3. 清理旧对象文件（防止链接错误）
rm -f buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-*/squashfs-tools/*.o
./build.sh recovery

2. 针对 Buildroot 主系统目录
# 1. 在头文件 squashfs_fs.h 第一行插入 sysmacros.h
sed -i '1i#include <sys/sysmacros.h>' \
buildroot/output/rockchip_rk3568/build/host-squashfs-*/squashfs-tools/squashfs_fs.h
# 2. 在 Makefile 中添加 -fcommon
sed -i 's/CFLAGS ?= -O2/CFLAGS ?= -O2 -fcommon/' \
buildroot/output/rockchip_rk3568/build/host-squashfs-*/squashfs-tools/Makefile
# 3. 清理旧对象文件
rm -f buildroot/output/rockchip_rk3568/build/host-squashfs-*/squashfs-tools/*.o
./build.sh buildroot

总结：你的编译流程
运行 ./build.sh recovery
遇到 m4 报错 -> 运行 一.1 的指令 -> 继续编译
遇到 squashfs 报错 -> 运行 三.1 的指令 -> 继续编译
(如果 fakeroot 没升级) 遇到 fakeroot 报错 -> 运行 二.1 的指令 -> 继续编译

运行 ./build.sh buildroot (编译主系统)
遇到 m4 报错 -> 运行 一.2 的指令 -> 继续编译
遇到 squashfs 报错 -> 运行 三.2 的指令 -> 继续编译
(如果 fakeroot 没升级) 遇到 fakeroot 报错 -> 运行 二.2 的指令 -> 继续编译


