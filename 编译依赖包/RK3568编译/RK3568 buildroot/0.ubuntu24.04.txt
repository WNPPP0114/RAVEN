在22.04的基础上修改uboot的gcc版本

这是一份经过完整梳理的 Ubuntu 24.04 编译 Rockchip SDK 终极修复指南。
这份指南整合了你之前的修复（Python2、DTC、U-Boot降级），并补全了解决 "Logo+Kernel卡死" 必须的内核修复（GZIP替换LZ4、Host工具修复）。
请直接复制每一段的指令块到终端执行。


准备工作：设置环境变量 (所有阶段通用)
#请根据你的实际目录修改 SDK_ROOT。
# === 0. 基础环境定义 ===
export SDK_ROOT=~/BSP/rk356x_linux  # <--- 请修改这里
export TOOLS_FIX="$SDK_ROOT/tools_fix"
export CROSS_TOOLchain="$SDK_ROOT/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-"

# 确保目录存在
mkdir -p $TOOLS_FIX/bin
echo "环境路径已设置: $SDK_ROOT"



第一阶段：智能构建环境 (只做缺失的部分)
cd $SDK_ROOT

# === 1. 智能安装系统依赖 ===
echo "正在检查系统依赖..."
# 只有当 dpkg 找不到包时才运行 apt install，节省时间
deps="build-essential libncurses5-dev libssl-dev libreadline-dev zlib1g-dev flex bison bc liblz4-tool device-tree-compiler"
for pkg in $deps; do
    if ! dpkg -s $pkg >/dev/null 2>&1; then
        echo "缺少 $pkg，正在安装..."
        sudo apt update
        sudo apt install -y $pkg
        break # 只要安装了一次，通常 apt 会把剩下的一起装好，或者你可以去掉 break 逐个装
    fi
done

# === 2. 智能构建 Python 2 ===
if [ -f "$TOOLS_FIX/bin/python" ] && [ "$($TOOLS_FIX/bin/python --version 2>&1 | cut -c 8-10)" == "2.7" ]; then
    echo "[跳过] Python 2.7 已就绪。"
else
    echo "[构建] 正在准备 Python 2..."
    # 优先检查系统是否有 python2
    if command -v python2 >/dev/null 2>&1; then
        ln -sf $(which python2) $TOOLS_FIX/bin/python
        ln -sf $(which python2) $TOOLS_FIX/bin/python2
        echo "已链接系统 Python2"
    else
        # 检查压缩包，没有才下载
        if [ ! -f "Python-2.7.18.tgz" ]; then
            echo "下载 Python 源码..."
            wget https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz
        fi
        
        # 解压并编译
        echo "编译 Python 2.7 (这可能需要几分钟)..."
        tar -xf Python-2.7.18.tgz
        cd Python-2.7.18
        ./configure --prefix=$TOOLS_FIX/py2_inst > /dev/null
        make -j$(nproc) > /dev/null && make install > /dev/null
        
        # 建立链接
        ln -sf $TOOLS_FIX/py2_inst/bin/python $TOOLS_FIX/bin/python
        ln -sf $TOOLS_FIX/py2_inst/bin/python $TOOLS_FIX/bin/python2
        cd ..
        # 清理源码目录保持整洁(可选)
        rm -rf Python-2.7.18
        echo "Python 2 编译完成。"
    fi
fi

# === 3. 智能构建 DTC (适配 GCC 10+) ===
if [ -f "$TOOLS_FIX/bin/dtc" ]; then
    echo "[跳过] DTC 1.4.7 已就绪。"
else
    echo "[构建] 正在准备 DTC 1.4.7..."
    if [ ! -f "dtc-1.4.7.tar.gz" ]; then
        wget https://git.kernel.org/pub/scm/utils/dtc/dtc.git/snapshot/dtc-1.4.7.tar.gz
    fi
    
    tar -xf dtc-1.4.7.tar.gz
    cd dtc-1.4.7
    make clean > /dev/null
    make NO_PYTHON=1 CFLAGS="-O2 -fcommon" -j$(nproc)
    cp dtc $TOOLS_FIX/bin/
    cd ..
    rm -rf dtc-1.4.7
    echo "DTC 构建完成。"
fi

# === 4. 最终验证 ===
echo "=== 环境检查 ==="
ls -l $TOOLS_FIX/bin/




第二阶段：源码修复 (防止反复添加代码)
cd $SDK_ROOT

# === 1. 修复 U-Boot (确保幂等性：无论跑多少次结果都一样) ===
cd u-boot
# 如果 Makefile 还没被修改过 (检查第一行是否包含 override)，才执行修改
if ! head -n 1 Makefile | grep -q "override CROSS_COMPILE"; then
    echo "[修复] 修改 U-Boot Makefile..."
    # 彻底清理旧的 override，防止重复堆叠
    sed -i '/^override/d' Makefile
    
    # 注入配置
    sed -i "1i\override LD = ${CROSS_TOOLchain}ld" Makefile
    sed -i "1i\override CROSS_COMPILE = $CROSS_TOOLchain" Makefile
else
    echo "[跳过] U-Boot Makefile 已经修复过了。"
fi
cd ..

# === 2. 修复 Kernel (核心步骤) ===
cd kernel

# A. 锁定编译器路径 (解决卡 Logo/重启)
if ! grep -q "CROSS_COMPILE := ${CROSS_TOOLchain}" Makefile; then
    echo "[修复] 锁定 Kernel 编译器路径..."
    sed -i '/^CROSS_COMPILE\s*?=/d' Makefile
    sed -i "2i\CROSS_COMPILE := ${CROSS_TOOLchain}" Makefile
else
    echo "[跳过] Kernel 编译器路径已锁定。"
fi

# B. 修复 Host 编译参数 (解决 scripts 编译报错)
if ! grep -q -- "-fcommon" Makefile; then
    echo "[修复] 添加 -fcommon 参数..."
    sed -i 's/^HOSTCFLAGS\s*:=/HOSTCFLAGS   := -fcommon /' Makefile
fi

# C. 修改 Defconfig (GZIP & BTF)
DEFCONFIG="arch/arm64/configs/rockchip_linux_defconfig"
echo "[配置] 强制刷新 Defconfig 设置..."

# 无论之前怎么设置，这里强制刷一遍 GZIP
# 1. 禁用 LZ4
sed -i 's/CONFIG_KERNEL_LZ4=y/# CONFIG_KERNEL_LZ4 is not set/g' $DEFCONFIG
# 2. 启用 GZIP (如果没找到 GZIP 行，就追加；如果找到了，就替换)
if grep -q "CONFIG_KERNEL_GZIP" $DEFCONFIG; then
    sed -i 's/# CONFIG_KERNEL_GZIP is not set/CONFIG_KERNEL_GZIP=y/g' $DEFCONFIG
else
    echo "CONFIG_KERNEL_GZIP=y" >> $DEFCONFIG
fi

# 3. 禁用 BTF (Ubuntu 24.04 必须)
sed -i 's/CONFIG_DEBUG_INFO_BTF=y/# CONFIG_DEBUG_INFO_BTF is not set/g' $DEFCONFIG

cd ..
echo "源码修复阶段完成。"



第三阶段：编译打包 (带环境注入)
# === 极速增量编译脚本 (防卡死最终版) ===

# 1. 基础变量
export SDK_ROOT=~/BSP/rk356x_linux
export TOOLS_FIX="$SDK_ROOT/tools_fix"
# 注意：这里 ARCH=arm64 是关键，必须全局导出！
export ARCH=arm64
export TOOLS_BIN="$TOOLS_FIX/bin"
export CROSS_TOOLchain="$SDK_ROOT/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-"

# 2. 智能计算线程数
CPU_CORES=$(nproc)
MEM_GB=$(free -g | awk '/^Mem:/{print $2}')
if [ "$MEM_GB" -lt "$CPU_CORES" ]; then
    SAFE_JOBS=$(($MEM_GB + 1))
    echo "ℹ️  内存限制: 使用 -j$SAFE_JOBS 线程编译"
else
    SAFE_JOBS=$CPU_CORES
    echo "🚀 性能全开: 使用 -j$SAFE_JOBS 线程编译"
fi

# 3. 注入关键环境变量
export PATH=$TOOLS_FIX/bin:$PATH
export CROSS_COMPILE=$CROSS_TOOLchain
export RK_KERNEL_TOOLCHAIN=$CROSS_TOOLchain

cd $SDK_ROOT

echo "========================================"
echo "▶️  开始增量编译..."
echo "========================================"

# === 编译 U-Boot ===
echo "-> [1/3] 编译 U-Boot..."
./build.sh uboot

# === 编译 Kernel (Direct Make 模式) ===
echo "-> [2/3] 编译 Kernel (Image & dtbs)..."
cd kernel

# 双重检查：确保配置没丢
if [ ! -f ".config" ]; then
    echo "❌ 错误：未找到 .config，请先运行 '3.1 清理脚本'！"
    exit 1
fi

# --- 配置修正区域 ---
# 1. 强制注入 GZIP 和 禁用 BTF
sed -i 's/CONFIG_KERNEL_LZ4=y/# CONFIG_KERNEL_LZ4 is not set/g' .config
sed -i 's/# CONFIG_KERNEL_GZIP is not set/CONFIG_KERNEL_GZIP=y/g' .config
grep -q "CONFIG_KERNEL_GZIP=y" .config || echo "CONFIG_KERNEL_GZIP=y" >> .config
sed -i 's/CONFIG_DEBUG_INFO_BTF=y/# CONFIG_DEBUG_INFO_BTF is not set/g' .config

# 2. 【关键修正】带 ARCH 参数同步配置
# 加上 yes "" 管道，如果有任何新选项，全部自动回车选默认值，绝不卡住
echo "-> 同步配置 (自动处理新增选项)..."
yes "" | make ARCH=arm64 oldconfig > /dev/null

# --------------------

# 直接调用 make
echo "-> 开始多核编译 (ARCH=arm64)..."
make ARCH=arm64 -j$SAFE_JOBS Image dtbs

# 检查是否成功
if [ ! -f "arch/arm64/boot/Image" ]; then
    echo "❌ Kernel 编译失败！请检查上方报错。"
    exit 1
fi
cd ..

# === 打包固件 ===
echo "-> [3/3] 打包固件..."
./build.sh uboot
./build.sh kernel
./build.sh recovery
./build.sh buildroot
./build.sh firmware
./build.sh updateimg

echo "#############################################"
echo "🎉 编译成功！"
echo "输出文件: rockdev/update.img"
echo "#############################################"
